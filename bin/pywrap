#!/usr/bin/env python

import os
import sys
try:
    import clang.cindex as ci
except:
    raise Exception("Install 'python-clang-3.5' and 'libclang-3.5-dev'")


CLASS_DEF = """cdef extern from "%(filename)s" namespace "%(namespace)s":
    cdef cppclass %(name)s:"""
METHOD_DEF = "        %(result_type)s %(name)s(%(args)s)"
CONSTRUCTOR_DEF = "        %(name)s(%(args)s)"
ARG_DEF = "%(tipe)s %(name)s"

PY_CLASS_DEF = """def Cpp%(name)s:
    cdef %(name)s *thisptr

    def __dealloc__(self):
        del self.thisptr
"""
PY_CONSTRUCTOR_DEF = """    def __cinit__(self):
        self.thisptr = new %(class_name)s()
"""
PY_METHOD_DEF = """    def %(pyname)s(%(args)s):%(convert_args)s
        self.%(name)s(%(cppargs)s)
"""
PY_ARG_DEF = "%(name)s"


class State:
    def __init__(self):
        self.namespace = ""
        self.last_function = None
        self.classes = []

    def to_pxd(self):
        return "\n".join(map(to_pxd, self.classes))

    def to_pyx(self):
        return "\n".join(map(to_pyx, self.classes))


class Clazz:
    def __init__(self, filename, namespace, name):
        self.filename = filename
        self.namespace = namespace
        self.name = name
        self.constructors = []
        self.methods = []

    def to_pxd(self):
        class_str = CLASS_DEF % self.__dict__
        consts_str = "\n".join(map(to_pxd, self.constructors))
        methods_str = "\n".join(map(to_pxd, self.methods))
        return class_str + "\n" + consts_str + "\n" + methods_str

    def to_pyx(self):
        class_str = PY_CLASS_DEF % self.__dict__
        consts_str = "\n".join(map(to_pyx, self.constructors))
        methods_str = "\n".join(map(to_pyx, self.methods))
        return class_str + "\n" + consts_str + "\n" + methods_str


class Method:
    def __init__(self, name, result_type):
        self.name = name
        self.arguments = []
        self.result_type = result_type

    def to_pxd(self):
        method_dict = {"args": ", ".join(map(to_pxd, self.arguments))}
        method_dict.update(self.__dict__)
        method_str = METHOD_DEF % method_dict
        return method_str

    def to_pyx(self):
        method_dict = {"args": ", ".join(map(to_pyx, self.arguments)),
                       "convert_args": convert_args(self.arguments),
                       "cppargs": ", ".join(map(cpparg, self.arguments))}
        method_dict.update(self.__dict__)
        method_dict["pyname"] = from_camel_case(method_dict["name"])
        method_str = PY_METHOD_DEF % method_dict
        return method_str


class Constructor:
    def __init__(self, name, class_name):
        self.name = name
        self.class_name = class_name
        self.arguments = []

    def to_pxd(self):
        const_dict = {"args": ", ".join(map(to_pxd, self.arguments))}
        const_dict.update(self.__dict__)
        const_str = CONSTRUCTOR_DEF % const_dict
        return const_str

    def to_pyx(self):
        const_dict = {"args": ", ".join(map(to_pyx, self.arguments))}
        const_dict.update(self.__dict__)
        const_str = PY_CONSTRUCTOR_DEF % const_dict
        return const_str


class Param:
    def __init__(self, name, tipe):
        self.name = name
        self.tipe = tipe

    def to_pxd(self):
        return ARG_DEF % self.__dict__

    def to_pyx(self):
        return PY_ARG_DEF % self.__dict__


def recurse(node, filename, state, verbose=0):
    namespace = state.namespace
    if verbose >= 2:
        print("Node: %s, %s" % (node.kind, node.displayname))

    if node.location.file is None:
        pass
    elif node.location.file.name != filename:
        return
    elif node.kind == ci.CursorKind.NAMESPACE:
        if state.namespace == "":
            state.namespace = node.displayname
        else:
            state.namespace = state.namespace + "::" + node.displayname
    elif node.kind == ci.CursorKind.PARM_DECL:
        param = Param(node.displayname, typename(node.type.spelling))
        state.last_function.arguments.append(param)
    elif node.kind == ci.CursorKind.CXX_METHOD:
        method = Method(node.spelling, typename(node.result_type.spelling))
        state.classes[-1].methods.append(method)
        state.last_function = method
    elif node.kind == ci.CursorKind.CONSTRUCTOR:
        constructor = Constructor(node.spelling, state.classes[-1].name)
        state.classes[-1].constructors.append(constructor)
        state.last_function = constructor
    elif node.kind == ci.CursorKind.CLASS_DECL:
        clazz = Clazz(filename, state.namespace, node.displayname)
        state.classes.append(clazz)
    else:
        if verbose:
            print("Unknown node: %s, %s" % (node.kind, node.displayname))

    for child in node.get_children():
        recurse(child, filename, state, verbose)

    state.namespace = namespace


def from_camel_case(name):
    new_name = str(name)
    i = 0
    while i < len(new_name):
        if new_name[i].isupper():
            new_name = new_name[:i] + "_" + new_name[i:]
            i += 1
        i += 1
    return new_name.lower()


def convert_args(arguments):
    names = map(cpparg, arguments)
    conversions = []
    skip = False
    for i in range(len(arguments)):
        if skip:
            skip = False
            continue
        cpptype = arguments[i].tipe
        pyname = arguments[i].name
        cppname = names[i]
        if cpptype in ["int", "float", "double"]:
            conversion = "cdef " + cpptype + " " + cppname + " = " + pyname
        elif cpptype == "double *":
            size = arguments[i].name
            # TODO delete
            conversion = """cdef double * %s = new double[%s]
        cdef int i
        for i in range(%s):
            %s[i] = %s[i]""" % (cppname, size, size, cppname, pyname)
            skip = True
        conversions.append("\n        " + conversion)
    return "".join(conversions)


def cpparg(arg):
    return "cpp" + to_pyx(arg)


def typename(name):
    # TODO does not work with std::vector<namespace::type>
    # Remove const modifier
    new_name = name.replace("const ", "")
    # Remove namespace
    return new_name.split("::")[-1]


def to_pxd(obj):
    return obj.to_pxd()


def to_pyx(obj):
    return obj.to_pyx()


if __name__ == "__main__":
    if len(sys.argv) < 2:
        raise Exception("No file name given")

    verbose = 0
    filename = sys.argv[1]

    tmpfile = filename
    header = (filename.endswith(".h") or
              filename.endswith(".hh") or
              filename.endswith(".hpp"))

    if header:
        tmpfile = filename + ".cc"
        with open(tmpfile, "w") as f:
            f.write(open(filename, "r").read())

    index = ci.Index.create()
    translation_unit = index.parse(tmpfile)
    cursor = translation_unit.cursor

    state = State()
    recurse(cursor, tmpfile, state, verbose)

    output = to_pxd(state)
    if header:
        output = output.replace(tmpfile, filename)
        os.remove(tmpfile)
    print(output)

    output = to_pyx(state)
    if header:
        output = output.replace(tmpfile, filename)
    print(output)
